<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Five in a Row</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden; /* Prevents scrolling on mobile */
        }
        .board-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(7, 1fr);
            border: 2px solid #4a5568;
            background-color: #2d3748;
            gap: 4px;
            padding: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .cell {
            width: 100%;
            padding-bottom: 100%; /* Maintain aspect ratio 1:1 */
            position: relative;
            background-color: #4a5568;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .cell:hover {
            background-color: #718096;
        }
        .cell .piece {
            position: absolute;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            transform: scale(0);
            /* Animation is now handled by JS for dynamic drop heights */
        }
        .red {
            background: radial-gradient(circle at 30% 30%, #ef4444, #b91c1c);
            box-shadow: inset 0 -4px 6px rgba(0,0,0,0.3), 0 5px 10px rgba(0,0,0,0.5);
        }
        .yellow {
            background: radial-gradient(circle at 30% 30%, #facc15, #ca8a04);
            box-shadow: inset 0 -4px 6px rgba(0,0,0,0.3), 0 5px 10px rgba(0,0,0,0.5);
        }
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }
        .modal-content {
            background: #2d3748;
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            width: 100%;
            max-width: 400px;
        }
        .action-button:disabled {
            background-color: #4a5568;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="text-center mb-4">
        <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold tracking-tight">Five in a Row</h1>
        <p id="status" class="text-base sm:text-lg text-gray-400 mt-2">Select your color to begin.</p>
    </div>

    <div id="board" class="board-grid w-full max-w-sm sm:max-w-lg md:max-w-2xl aspect-[9/7]">
        <!-- Cells will be generated by JavaScript -->
    </div>

    <div class="mt-4 sm:mt-6 flex space-x-4">
        <button id="undo-button" class="action-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 sm:py-2 sm:px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">
            Undo
        </button>
        <button id="reset-button" class="action-button bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 sm:py-2 sm:px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">
            Reset Game
        </button>
    </div>

    <!-- Setup Modal -->
    <div id="setup-modal" class="modal-overlay">
        <div class="modal-content">
            <!-- Step 1: Color Selection -->
            <div id="color-selection">
                <h2 class="text-xl sm:text-2xl font-bold mb-6">Choose Your Color</h2>
                <div class="flex justify-center gap-6">
                    <button id="select-red" class="w-16 h-16 sm:w-20 sm:h-20 rounded-full piece red transform hover:scale-110 transition-transform"></button>
                    <button id="select-yellow" class="w-16 h-16 sm:w-20 sm:h-20 rounded-full piece yellow transform hover:scale-110 transition-transform"></button>
                </div>
            </div>
            <!-- Step 2: Starter Selection -->
            <div id="starter-selection" class="hidden">
                <h2 class="text-xl sm:text-2xl font-bold mb-6">Who Goes First?</h2>
                <div class="flex justify-center gap-4 sm:gap-6">
                    <button id="start-player" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 sm:px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">Me</button>
                    <button id="start-ai" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 sm:px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">AI</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="game-over-message" class="text-2xl sm:text-3xl font-bold mb-6"></h2>
            <button id="play-again-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>


    <script>
        // --- Game Constants and State ---
        const ROWS = 7;
        const COLS = 9;
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('reset-button');
        const undoButton = document.getElementById('undo-button');
        const setupModal = document.getElementById('setup-modal');
        const colorSelectionDiv = document.getElementById('color-selection');
        const starterSelectionDiv = document.getElementById('starter-selection');
        const gameOverModal = document.getElementById('game-over-modal');

        let board = [];
        let playerColor = null;
        let aiColor = null;
        let currentPlayer = null;
        let gameOver = false;
        let aiPersonality = 'balanced';
        let moveHistory = []; // To track moves for undo

        const PLAYER = 1;
        const AI = 2;

        // --- Initialization ---

        function init() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
            gameOver = false;
            currentPlayer = null;
            moveHistory = [];
            boardElement.innerHTML = '';
            
            const personalities = ['aggressive', 'defensive', 'balanced'];
            aiPersonality = personalities[Math.floor(Math.random() * personalities.length)];
            
            createBoard();
            setupModal.classList.remove('hidden');
            colorSelectionDiv.classList.remove('hidden');
            starterSelectionDiv.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            statusElement.textContent = 'Game setup in progress...';
            updateUndoButtonState();
        }

        function createBoard() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', handleCellClick);
                    boardElement.appendChild(cell);
                }
            }
        }
        
        // --- Event Handlers ---

        document.getElementById('select-red').addEventListener('click', () => selectColor('red'));
        document.getElementById('select-yellow').addEventListener('click', () => selectColor('yellow'));
        document.getElementById('start-player').addEventListener('click', () => beginGame(PLAYER));
        document.getElementById('start-ai').addEventListener('click', () => beginGame(AI));
        resetButton.addEventListener('click', init);
        document.getElementById('play-again-button').addEventListener('click', init);
        undoButton.addEventListener('click', handleUndo);

        function selectColor(color) {
            playerColor = color;
            aiColor = color === 'red' ? 'yellow' : 'red';
            colorSelectionDiv.classList.add('hidden');
            starterSelectionDiv.classList.remove('hidden');
        }

        function beginGame(starter) {
            currentPlayer = starter;
            setupModal.classList.add('hidden');

            if (currentPlayer === PLAYER) {
                statusElement.textContent = `You are ${playerColor}. Your turn!`;
            } else {
                statusElement.textContent = `You are ${playerColor}. AI starts.`;
                setTimeout(aiMove, 500);
            }
            updateUndoButtonState();
        }

        function handleCellClick(event) {
            if (gameOver || currentPlayer !== PLAYER) return;
            
            const col = parseInt(event.currentTarget.dataset.col);
            const row = findLowestEmptyRow(col);

            if (row !== -1) {
                makeMove(row, col, PLAYER);
                if (checkWin(PLAYER)) {
                    endGame(PLAYER);
                    return;
                }
                switchPlayer();
                setTimeout(aiMove, 500);
            }
        }

        // --- Game Logic ---

        function findLowestEmptyRow(col) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === 0) return r;
            }
            return -1;
        }

        function makeMove(row, col, player) {
            board[row][col] = player;
            moveHistory.push({ row, col, player });

            const piece = document.createElement('div');
            piece.classList.add('piece', player === PLAYER ? playerColor : aiColor);
            
            const topCell = boardElement.querySelector(`[data-row='0'][data-col='${col}']`);
            const targetCell = boardElement.querySelector(`[data-row='${row}'][data-col='${col}']`);
            
            const dropHeight = targetCell.offsetTop - topCell.offsetTop;
            
            piece.style.animation = 'none';
            targetCell.appendChild(piece);
            
            const dynamicDropKeyframes = `@keyframes dynamicDrop-${row}-${col} {
                from { transform: translateY(-${dropHeight}px); }
                70% { transform: translateY(0) scale(1.1); }
                to { transform: translateY(0) scale(1); }
            }`;
            const styleSheet = document.styleSheets[0];
            try { styleSheet.insertRule(dynamicDropKeyframes, styleSheet.cssRules.length); } catch(e) {}
            
            piece.style.animation = `dynamicDrop-${row}-${col} 0.5s cubic-bezier(0.5, 0.05, 0.5, 1.5) forwards`;
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === PLAYER) ? AI : PLAYER;
            statusElement.textContent = currentPlayer === PLAYER ? "Your turn" : "AI is thinking...";
            updateUndoButtonState();
        }

        function checkWin(player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] === player) {
                        for (const [dr, dc] of directions) {
                            let count = 1;
                            for (let i = 1; i < 5; i++) {
                                const nr = r + i * dr;
                                const nc = c + i * dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && board[nr][nc] === player) count++;
                                else break;
                            }
                            if (count >= 5) return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function endGame(winner) {
            gameOver = true;
            const messageElement = document.getElementById('game-over-message');
            if (winner === PLAYER) messageElement.textContent = "You Win! Impressive!";
            else if (winner === AI) messageElement.textContent = "AI Wins!";
            else messageElement.textContent = "It's a Draw!";
            statusElement.textContent = winner === PLAYER ? "Congratulations!" : "Game Over.";
            gameOverModal.classList.remove('hidden');
            updateUndoButtonState();
        }

        // --- Undo Logic ---
        function handleUndo() {
            if (gameOver || currentPlayer !== PLAYER || moveHistory.length === 0) return;
            
            const lastPlayerMoveIndex = moveHistory.map(m => m.player).lastIndexOf(PLAYER);
            if (lastPlayerMoveIndex === -1) return;

            const movesToUndo = moveHistory.length - lastPlayerMoveIndex;

            for (let i = 0; i < movesToUndo; i++) {
                const lastMove = moveHistory.pop();
                if (lastMove) {
                    board[lastMove.row][lastMove.col] = 0;
                    const cell = boardElement.querySelector(`[data-row='${lastMove.row}'][data-col='${lastMove.col}']`);
                    cell.innerHTML = '';
                }
            }

            currentPlayer = PLAYER;
            statusElement.textContent = "Your turn. Move undone.";
            updateUndoButtonState();
        }

        function updateUndoButtonState() {
            const lastPlayerMoveIndex = moveHistory.map(m => m.player).lastIndexOf(PLAYER);
            undoButton.disabled = gameOver || currentPlayer !== PLAYER || lastPlayerMoveIndex === -1;
        }

        // --- AI Logic ---
        
        function aiMove() {
            if (gameOver) return;
            const bestMove = findBestMove();
            if (bestMove) {
                makeMove(bestMove.row, bestMove.col, AI);
                if (checkWin(AI)) {
                    endGame(AI);
                    return;
                }
                switchPlayer();
            } else {
                // NOTE: With the hyper-aggressive AI, this 'draw' state should theoretically
                // never be reached, as the AI is designed to force a win before the board fills up.
                endGame(null); // Draw
            }
        }

        function findBestMove() {
            // Priority 1 & 2: Immediate win or block
            for (let p of [AI, PLAYER]) {
                for (let c = 0; c < COLS; c++) {
                    const r = findLowestEmptyRow(c);
                    if (r !== -1) {
                        board[r][c] = p;
                        if (checkWin(p)) {
                            board[r][c] = 0; return { row: r, col: c };
                        }
                        board[r][c] = 0;
                    }
                }
            }

            // Priority 3: Heuristic evaluation
            let bestScore = -Infinity;
            let bestMoves = [];
            const columnOrder = [4, 3, 5, 2, 6, 1, 7, 0, 8];

            let offenseWeight = 1.0, defenseWeight = 1.0;
            if (aiPersonality === 'aggressive') offenseWeight = 1.2;
            if (aiPersonality === 'defensive') defenseWeight = 1.2;

            for (const c of columnOrder) {
                const r = findLowestEmptyRow(c);
                if (r !== -1) {
                    let score = evaluatePosition(r, c, AI) * offenseWeight + evaluatePosition(r, c, PLAYER) * defenseWeight;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [{ row: r, col: c }];
                    } else if (score === bestScore) {
                        bestMoves.push({ row: r, col: c });
                    }
                }
            }
            
            if (bestMoves.length > 0) {
                return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }

            // Fallback
            for (let c of columnOrder) {
                const r = findLowestEmptyRow(c);
                if (r !== -1) return { row: r, col: c };
            }
            return null;
        }

        function evaluateWindow(window, player) {
            const opponent = (player === PLAYER) ? AI : PLAYER;
            let score = 0;
            const playerCount = window.filter(p => p === player).length;
            const emptyCount = window.filter(p => p === 0).length;
            const opponentCount = window.filter(p => p === opponent).length;

            if (opponentCount > 0) return 0; // A blocked line is worthless.

            // New hyper-aggressive scoring to force a win and prevent draws.
            if (playerCount === 4) {
                score += 1000000; // This is a winning move, give it a massive score.
            } else if (playerCount === 3 && emptyCount === 2) {
                score += 50000;   // An "open three" is a huge threat that often leads to a win.
            } else if (playerCount === 3) {
                score += 1000;    // A regular three-in-a-row.
            } else if (playerCount === 2 && emptyCount === 3) {
                score += 500;     // An "open two" is a good setup for future threats.
            } else if (playerCount === 2) {
                score += 100;     // A regular two-in-a-row.
            }

            return score;
        }

        function evaluatePosition(row, col, player) {
            let totalScore = 0;
            board[row][col] = player;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (const [dr, dc] of directions) {
                for (let i = -4; i <= 0; i++) {
                    let window = [];
                    let isValidWindow = true;
                    for (let j = 0; j < 5; j++) {
                        const r = row + (i + j) * dr;
                        const c = col + (i + j) * dc;
                        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) window.push(board[r][c]);
                        else { isValidWindow = false; break; }
                    }
                    if (isValidWindow) totalScore += evaluateWindow(window, player);
                }
            }
            board[row][col] = 0;
            return totalScore;
        }

        // --- Start the game ---
        window.onload = init;
    </script>
</body>
</html>
